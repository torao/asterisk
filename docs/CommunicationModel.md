# Communication Model

## Asynchronous Execution

asterisque メッセージインタラクションは全て非同期に行われます。Queue や Promise を使用して非同期処理を同期化することはそれほど難しいことではありません。非同期で実装されたアプリケーションは並列実行性能に優れ、少ないリソース消費で大量の処理を実行する特性のアプリケーションに向いています。一方で同期型のアプリケーションは処理の流れが単純で読みやすく実装しやすい利点があります。アプリケーションの特性に合わせて選択することができます。

一般に、同期処理は輻輳が増加し全体としてのパフォーマンスが劣化します。

## Client and Server

asterisque は通信端点の双方でサービスを提供できるため一般的なネットワーク構成に比べてクライアント/サーバの役割は明確でありません。しかし状態管理を行う上でどちらが「それ」を行うのか事前に取り決めておくことで省略できる手順も多くあります。asterisque ではセッションの開始要求を出した側を**クライアント**、それを受け付けた側を**サーバ**と定義しています。

## Remote Procedure Call
## Message Passing and Streaming

アプリケーションは Pipe が構築されてから消滅するまでの間 (つまり Open から Close までの間)、その Pipe を使用して任意の Block メッセージを送受信することができます。この Block メッセージを使用してセッション上で双方向の非同期メッセージングを行うことができます。

Block メッセージを使用した非同期メッセージングは RPC に比べて Open-Close のラウンドトリップのオーバーヘッドがなくイベント通知やストリーミングに適しています。

Java/Scala 実装では Future ベースの非同期 filter-map-reduce を行うことが出来る。

## BLOB Transmission

メッセージは単体でメモリ上に保持できる大きさを想定しているため、Open メッセージのパラメータや Close メッセージの結果にはあまり大きなデータを持たせることができません。ファイルのような数 MB を超えるデータを送受信するのにも Block メッセージを使用することができます。

非同期メッセージングは順序性を保証しており、Block シーケンスの終了を表す EOF も標準で定義しています。大きなデータを Block メッセージに収まるチャンクに分割して転送することで受信側でデータを復元することが出来ます。